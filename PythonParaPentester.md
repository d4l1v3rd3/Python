# Python para pentesters

Python es una herramientas muy fuerte que debemos tener y saber en nuestro arsenal gracias ella podemos llegar a construir multitud de herramientas para pentesting. 

Aquí no explicare todos los detalles que puedes llegar a hacer con python pero vamos a ello, pero cubriremos varias áreas clave que serán útiles durante las interacciones y nos ayudarán a comprender mejor Python:

(Antes de nada saber que hay que tener un minimo conocimiento, lo que es una variable, bucle, función, etc)

que veremos:

- Usar python para enumerar subdominios
- Crear un simple keylogger
- Escanear una red para buscar targets
- Escanear cualquier target para buscar puertos abiertos
- Descargar archivos de internet
- Crackear hashes

Cualquier codigo que haremos se puede compilar con herramientas simples.

# Enumeración de Subdominios

Gracias a python tenemos la posibilidad de automatizar tareas como pentester. Si automatizamos prodcesos la curva de aprendizaje es muchisimo mejor.

Buscar subdominios de una organización por ejemplo "nodo313.net" es una forma efectiva de buscar o encontrar vulnerabilidades.

```
import requests 
import sys 

sub_list = open("subdomains.txt").read() 
subdoms = sub_list.splitlines()

for sub in subdoms:
    sub_domains = f"http://{sub}.{sys.argv[1]}" 

    try:
        requests.get(sub_domains)
    
    except requests.ConnectionError: 
        pass
    
    else:
        print("Dominio valido: ",sub_domains)
```

## Explicación del Código:

- import requests: Importa la biblioteca requests, que se usa para hacer solicitudes HTTP.
- import sys: Permite acceder a argumentos de la línea de comandos.
- sub_list = open("subdomains.txt").read(): Abre el archivo subdomains.txt y lee todo su contenido.
- subdoms = sub_list.splitlines(): Divide el contenido del archivo en líneas individuales. Cada línea representa un subdominio.
- for sub in subdoms:: Itera sobre cada subdominio en la lista.
- sub_domains = f"http://{sub}.{sys.argv[1]}": Construye la URL con el subdominio y el dominio base pasado como argumento en la línea de comandos (sys.argv[1]). El resultado es algo como http://subdominio.dominio.com.
- try:: Intenta hacer una solicitud HTTP al subdominio.
- requests.get(sub_domains): Hace una solicitud GET a la URL construida.
- except requests.ConnectionError:: Si hay un error de conexión (por ejemplo, el subdominio no existe), simplemente lo ignora.
- else:: Si la solicitud es exitosa (no hay error), imprime el subdominio como un dominio válido.


![image](https://github.com/user-attachments/assets/bdbbe5a3-57f0-448e-8d61-742a7347dd26)


# Enumeración de directorios

En este punto ya conocemos lo que es el reconocimiento, sin decir que es el paso mas importante

Vamos a otro ejemplo:

```
import requests 
import sys 

sub_list = open("wordlist.txt").read() 
directories = sub_list.splitlines()

for dir in directories:
    dir_enum = f"http://{sys.argv[1]}/{dir}.html" 
    r = requests.get(dir_enum)
    if r.status_code==404: 
        pass
    else:
        print("Directorio valido:" ,dir_enum)
```

Como podemos ver es casi igual que el de subdominio. La unica diferencia esque utilizamos el estatus "404" para las respuestas (Es el código que se utiliza para decirnos que no ha cogido recursos de la página).

- No creo que tenga que explicar que utiliza la wordlist "wordlist.txt"
- Utiliza las mismas funciones con diferencia que añadimos /{dir} para referirnos al directorio en cuestion "http://nodo313.net/index.html"
- La respuesta 404 es muy importante porque en caso de recibir eso sabriamos que dicho directorio no tenemos acceso o no existe.

```
Valid directory: http://10.10.180.120/surfer.html
Valid directory: http://10.10.180.120/private.html
Valid directory: http://10.10.180.120/apollo.html
Valid directory: http://10.10.180.120/index.html
```
# Escaner de red

Python se puede crear para crear ICMP simples, para escanear o identificar targets potenciales en la red, Sin embargo los paquetes ICMP pueden ser monitorizados o bloqueados por el target de la organización, como si fuera un ping a un servidor. Esta es una de las muchas razones porque normalmente se usa ARP siendo mucho mas efectivo.

```
from scapy.all import *

interface = "eth0"
ip_range = "10.10.X.X/24"
broadcastMac = "ff:ff:ff:ff:ff:ff"

packet = Ether(dst=broadcastMac)/ARP(pdst = ip_range) 

ans, unans = srp(packet, timeout =2, iface=interface, inter=0.1)

for send,receive in ans:
        print (receive.sprintf(r"%Ether.src% - %ARP.psrc%"))
```

En caso de no tener scripy 

```
apt install python3-scapy
```

# Escaner de puertos

```
apt install python3-pyfiglet
```

En esta tarea crearemos un simple escaner de puertos

```
import sys
import socket
import pyfiglet


ascii_banner = pyfiglet.figlet_format("d4l1 \n Python 4 Pentesters \nEscaner de puertos")
print(ascii_banner)


ip = '192.168.1.6' 
open_ports =[] 

ports = range(1, 65535)


def probe_port(ip, port, result = 1): 
  try: 
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
    sock.settimeout(0.5) 
    r = sock.connect_ex((ip, port))   
    if r == 0: 
      result = r 
    sock.close() 
  except Exception as e: 
    pass 
  return result


for port in ports: 
    sys.stdout.flush() 
    response = probe_port(ip, port) 
    if response == 0: 
        open_ports.append(port) 
    

if open_ports: 
  print ("Open Ports are: ") 
  print (sorted(open_ports)) 
else: 
  print ("Looks like no ports are open :(")
```

# Descargar archivos


# Ejercicios para el nodo:

También he considerado que esta guay para que aprendais un poco y busqueis y os ire haciendo alguna preguntilla y si quiereis la buscais o respondeis en el mismo foro:

¿Que herramienta podemos utilizar para convertir los scripts de python en ejecutables de windows?

¿Que otro protocolo podemos usar para enumerar subdominios?

¿Que función de python hemos utilizado en el ejemplo de enumeración de subdominio para escribir desde la línea de comandos?


